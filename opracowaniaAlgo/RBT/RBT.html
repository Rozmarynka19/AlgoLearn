<!DOCTYPE html>
<html>

<head>
<script language="javascript">
 function renev()
 {
   var p_list = document.getElementsByTagName("div");
    for(var i=p_list.length-1; i>=0; i--){
        var p = p_list[i];
        if(p.className == "insert" || p.className == "rotacje" || p.className == "search" || p.className == "wprowadzenie" || p.className == "del"){
			p.hidden = true;
        }
    }
   alert('test');

 }
 function test1()
 {
   var p_list = document.getElementsByTagName("div");
    for(var i=p_list.length-1; i>=0; i--){
        var p = p_list[i];
        if(p.className == "insert"){
			p.hidden = false;
        }
    }
   alert('test');

 }
  function test1()
 {
   var p_list = document.getElementsByTagName("div");
    for(var i=p_list.length-1; i>=0; i--){
        var p = p_list[i];
        if(p.className == "insert"){
			p.hidden = false;
        }
    }
   alert('test');

 }
 function test2()
 {
   var p_list = document.getElementsByTagName("div");
    for(var i=p_list.length-1; i>=0; i--){
        var p = p_list[i];
        if(p.className == "rotacje"){
			p.hidden = false;
        }
    }
   alert('test');

 }
 function test3()
 {
   var p_list = document.getElementsByTagName("div");
    for(var i=p_list.length-1; i>=0; i--){
        var p = p_list[i];
        if(p.className == "search"){
			p.hidden = false;
        }
    }
   alert('test');

 }
 function test4()
 {
   var p_list = document.getElementsByTagName("div");
    for(var i=p_list.length-1; i>=0; i--){
        var p = p_list[i];
		if(p.className == "wprowadzenie"){
			p.hidden = false;
		}
    }
   alert('test');

 }
  function test5()
 {
   var p_list = document.getElementsByTagName("div");
    for(var i=p_list.length-1; i>=0; i--){
        var p = p_list[i];
		if(p.className == "del"){
			p.hidden = false;
		}
    }
   alert('test');

 }
 </script>
 <style>
 body
{
    margin:0;
    padding:0;
    /* background-color: black; */
}

.red
{
    color:red;
}

h1,h4,h3
{
    text-align: center;
    line-height: 0;
}

h1
{
    padding: 10px  0px  5px  0px
} 

.intro
{
    padding: 20px 50px;
}

.parallel
{
    float: left;
}

.below
{
    clear: both;
}

.imgIntro
{
    display: block;
    margin-left: auto;
    margin-right: auto;
    width:25%;
    height:25%;
}

.imgRotations, .imgSearch, .imgInsert
{
    padding:20px 60px;
}

/* #Lrotation,#Rrotation,#resume
{
    padding: 10px;
} */

section
{
    padding: 10px;
}
</style>
 <meta charset="UTF-8">

</head>

<body id="up">
    <h1>Drzewo <span class="red">czerwono</span>-czarne</h1>
    <h4>(ang. <span class="red">red</span>-black tree)</h4>
    
<div class="wprowadzenie">
    <div class="intro">
        <h3><u>Wprowadzenie - ogólne zasady</u></h3>
        <p>
            Drzewo czerwono-czarne jest samorównoważącym się binarnym drzewem poszukiwań <i>(ang. self-balancing binary
                search tree)</i>.
            Zachowuje podstawowe własnosci drzew BST:
        <ul>
            <li>klucz lewego dziecka &lt klucz rodzica &lt klucz prawego dziecka</li>
            <li>klucze w drzewie są posortowane (konsekwencja powyższego)</li>
            <li>klucze po lewej stronie węzła są mniejsze od tego węzła (konsekwencja pierwszego punktu)</li>
            <li>klucze po prawej stronie węzła są większe od tego węzła (konsekwencja pierwszego punktu)</li>
            <li>każde węzeł może mieć 2 poddrzewa</li>

        </ul>
        </p>

        <i class="red">
            Uwaga: jeśli nie wiesz, czym są drzewa BST lub nie pamiętasz ich właściwości - wróć proszę do materiału o
            BST.
            Ta wiedza jest niezbędna, aby zrozumieć działanie drzew RBT!
        </i>
        <br/>
        <br/>

        <div class="parallel">
            Jednak na ten typ drzew zostały nałożone dodatkowe obostrzenia:
            <ul>
                <li>każdy węzeł może być koloru albo czerwonego, albo czarnego</li>
                <li>jeśli węzeł jest czerwony, to jego dzieci MUSZĄ być czarne</li>
                <li>korzeń oraz liście drzewa są czarne</li>
                <li>każda ścieżka z dowolnego węzła do liścia ma taką samą ilość czarnych węzłów</li>
            </ul>
        </div>
        <img class="imgIntro" src="../textimg/RBTimg/intro/rbt_intro.png" />
        <i class="red">
            Uwaga: Nasza wizualizacja drzewa RBT, którą zobaczysz później nie pokazuje liści. Pamiętaj, że domyślnie one
            tam są!
        </i>
        <br/>
        <br/>

        <p>
            Jakie operacje możemy wykonać na naszym drzewku? Standardowe operacje, tj.:
            <ul>
                <li>Wyszukać węzeł po kluczu</li>
                <li>Dodać węzeł</li>
                <li>Usunąć węzeł</li>
            </ul>
            Co ważne, dwie ostatnie operacje mogą wymagać rotacji, aby naprawić "drzewko" - czyli zachować wszystkie jego
            właściwości
            Jeśli o to zadbamy, drzewko "odwdzięczy się" nam w postaci złożoności obliczeniowej na poziomie O(logN) dla
            wszystkich operacji.
            A co z zajętością przestrzeni? Tu nie ma rady - musimy trzymać wszystkie węzły, zatem wynosi ona O(N).
        </p>
    </div>
</div>
	
<div class="insert">	
	<div class="intro">
        <h3><u>Wstawianie węzła</u></h3>
        <p>
            Kolejną standardową operacją w drzewach czerwono-czarnych jest wstawianie węzła. Przyjmiemy następującą strategię:
            <ul>
                <li>Wyszukamy miejsce dla wstawianego węzła (nie pozwalamy wstawiać węzła, którego klucz już istnieje)</li>
                <li>Wstawiamy węzeł w to miejsce i kolorujemy go na czerwono</li>
                <li>Dokonujemy naprawy drzewka (rotacje,przekolorowanie węzłów)</li>
            </ul>
            Ale po kolei...
            <br/>
            <br/>
            Spis treści (kliknij, by nie scrollować ;]):
            <ul>
                <li><a href="#relationships">Relacje w drzewku</a></li>
                <li><a href="#scenarioNo1">1. scenariusz - wstawiany węzeł jest korzeniem</a></li>
                <li><a href="#scenarioNo2">2. scenariusz - wujek wstawianego węzła jest czerwony</a></li>
                <li><a href="#scenarioNo3">3. scenariusz - wujek wstawianego węzła jest czarny (formacja trójkątna)</a></li>
                <li><a href="#scenarioNo4">4. scenariusz - wujek wstawianego węzła jest czarny (formacja liniowa)</a></li>
                <!-- <li><a href="#resume">Podsumowanie</a></li> -->
            </ul>
            <br/>
        </p>


        <section id="relationships">
            <p>
                <h4>Relacje w drzewku</h4>
                Krótkie przypomnienie relacji w drzewku na poniższym przykładzie.
                <br/>

                <img style="display: block;
                width: 80%;" class="imgInsert" src="../textimg/RBTimg/insert/insert_relationship1.png"/>
				</div>
                <br/>
                Chcemy określić "who is who" dla węzła o kluczu "23" (ten zaznaczony z żółtą obręczą ;]).
                <ul>
                    <li>Węzeł bezpośrednio nad nim jest jego <b>rodzicem</b>.</li>
                    <li>Rodzic jego rodzica jest jego <b>dziadkiem</b>.</li>
                    <li>Brat jego rodzica jest jego <b>wujkiem</b>.</li>
                </ul>
                Tak jak w rodzinie :). Nothing fancy. Możemy przejść do scenariuszy wstawiania - 
                czyli na jakie sytuację możemy się natknąć po wstawieniu węzła.
                <br/>
                <img class="imgInsert" src="../textimg/RBTimg/insert/insert_relationship2.png"/>
            </p>
        </section>


        <section id="scenarioNo1">
            <p>
                <h4>1. scenariusz - wstawiany węzeł jest korzeniem</h4>
                <br/>
                Nazwa przypadku mówi za siebie - mamy puste drzewko, wstawiamy pierwszy węzeł, staje się on automatycznie korzeniem. Ale...
                <br/>
                We wprowadzeniu do tematu zaznaczyliśmy, że będziemy wstawiali węzeł i go kolorowali na czerwono.
                Pamiętasz, jakiego koloru powinien być korzeń w RBT? Czarnego! To co musimy zrobić? Przekolorować wstawiony węzeł na czarny! Koniec.
                <br/>
                <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario1.gif"/>
            </p>
        </section>

        <section id="scenarioNo2">
            <p>
                <h4>2. scenariusz - wujek wstawianego węzła jest czerwony</h4>
                <br/>
                Załóżmy, że mamy takie <b>poddrzewo</b> (ważne, że jest to poddrzewo; dlaczego, wyjaśnimy później).
                <br/>
                <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario2_1.png"/>
                <br/>
                Wstawiamy nowy węzeł, np. o kluczu "3".
                <br/>
                <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario2_2.png"/>
                <br/>
                I co się stało? Czy węzeł czerwony ma jakieś obostrzenia dotyczące koloru jego dzieci? Muszą być czarne, prawda?
                Ale zamiast przekolorywać wstawiony węzeł na czarno robimy inaczej. Zerknijmy, jakiego koloru jest wujek wstawionego węzła.
                <br/>
                <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario2_3.png"/>
                <br/>
                Jest czerwony. Zatem zmieniamy kolory rodzica, dziadka i wujka węzła o kluczu "3" na przeciwne.
                <br/>
                <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario2_4.png"/>
                <br/>
                I koniec. Nasze poddrzewko jest naprawione. <b>Poddrzewko</b>, bo gdyby to było pełne drzewo, 
                to jeszcze musielibyśmy zmienić kolor korzenia na czarny, jak poniżej.
                <br/>
                <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario2_5.png"/>
                <br/>
                Podsumowując - wstawiamy węzeł, wujek czerwony, zmieniamy kolory.
                <br/>
                <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario2.gif"/>
                <br/>
            </p>
        </section>

        <section id="scenarioNo3">
            <p>
                <h4>3. scenariusz - wujek wstawianego węzła jest czarny (formacja trójkątna)</h4>
                <br/>
                Zadaniem głównym tego scenariusza jest doprowadzenie poddrzewa do stanu początkowego formacji liniowej.
                Jest to zatem pewien etap naprawy, a nie cały proces. Co ważne, możemy mieć prawą i lewą formację trójkątną.
                Tak samo, jak przy rotacjach - są to symetryczne sytuacje względem siebie. Przejdźmy do przykładu...
                <br/>
                Mamy takie podrzewo. Załóżmy, że przed chwilą wstawiliśmy węzeł o kluczu "15"
                <br/>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario3L_0.png"/>
                </div>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario3R_0.png"/>
                </div>
                <div class="below"></div>
                <br/>
                Po lewej stronie jest lewa formacja trójkątna , ponieważ ma wierzchołek trójkąta po lewej stronie. 
                Analogicznie, po prawej stronie mamy prawą formacje trójkątną, ponieważ ma wierzchołek po prawej stronie.
                Sprawdźmy, jakiego koloru jest wujek :).
                <br/>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario3L_1.png"/>
                </div>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario3R_1.png"/>
                </div>
                <div class="below"></div>
                <br/>
                Jest koloru czarnego. Ojej, czeka nas więcej pracy przy naprawie drzewka. Co robimy?
                W lewej formacji trójkątnej rotujemy rodzica nowo wstawionego węzła o kluczu "15" w lewą stronę. 
                Odpowiednio, w prawej formacji trójkątnej rotujemy rodzica nowo wstawionego węzła o kluczu "15" w prawą stronę. 
                <br/>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario3L_2.png"/>
                </div>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario3R_2.png"/>
                </div>
                <div class="below"></div>
                <br/>
                Otrzymujemy odpowiednio lewą i prawą formację liniową, a tym samym - sytuację wejściową do 4. scenariusza.
                Chcąc naprawić drzewko, trzeba się teraz przełączyć na ostatni scenariusz, a wszystkie operacje będą wykonywane z perspektywy
                rodzica wstawianego węzła o kluczu "15".
                <br/>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario3L_4.png"/>
                </div>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario3R_4.png"/>
                </div>
                <div class="below"></div>
            </p>
        </section>

        <section id="scenarioNo4">
            <p>
                <h4>4. scenariusz - wujek wstawianego węzła jest czarny (formacja liniowa)</h4>
                <br/>
                Okej, możemy miec 2 sytuacje początkowe:
                <ul>
                    <li>naprawiliśmy formację trójkątną i patrzymy teraz na drzewko po dokonanej rotacji z perspektywy rodzica wstawionego węzła,
                        który stworzył formację trójkątną
                    </li>
                    <li>przed chwilą wstawiliśmy nowy węzeł i po wstawieniu od razu stworzył formację liniową</li>
                </ul>
                <br/>
                Podobnie, możemy mieć lewą i prawą formację liniową (wstawiony węzeł, rodzic i dziadek tworzą odpowiednio lewy lub prawy skos).
                <br/>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario4L_1.png"/>
                </div>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario4R_1.png"/>
                </div>
                <div class="below"></div>
                <br/>
                Aby naprawić drzewko, najpierw rotujemy dziadka w prawo, jeśli jest to lewa formacja liniowa lub w lewo, 
                jeśli jest to prawa formacja liniowa. Węzeł na szaro pokazuje, co się dzieje w rotacji, 
                gdyby tam był węzeł dowolnego koloru (czerwony lub czarny).
                <br/>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario4L_2.png"/>
                </div>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario4R_2.png"/>
                </div>
                <div class="below"></div>
                <br/>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario4L_4.png"/>
                </div>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario4R_4.png"/>
                </div>
                <div class="below"></div>
                <br/>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario4L_5.png"/>
                </div>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario4R_5.png"/>
                </div>
                <div class="below"></div>
                <br/>
                Ostatni krok, to przekolorowanie na przeciwny kolor rodzica i dziadka dodanego węzła.
                <br/>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario4L_6.png"/>
                </div>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario4R_6.png"/>
                </div>
                <div class="below"></div>
                <br/>
                Poniższe animacje pokazują krok po kroku operacje wykonane w scenariuszu 3 i 4.
                <br/>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario3&4L.gif"/>
                </div>
                <div class="parallel">
                    <img class="imgInsert" src="../textimg/RBTimg/insert/insert_scenario3&4R.gif"/>
                </div>
                <div class="below"></div>
            </p>
        </section>

        <section id="resume">
            <p>
                <h4>Podsumowanie</h4>
                Strzeżcie się czarnych wujków ;)
            </p>
        </section>

        <a href="#up">Powrót do góry</a>
    </div>
</div>

<div class="rotacje">	
	<div class="intro">
        <h3><u>Rotacje</u></h3>
        <p>
            Rotacje są ważnym elementem drzew czerwono-czarnych. Polegają one na zmianie struktury drzewka poprzez
            zmianę poddrzew.
            Głównym celem rotacji jest zmniejszenie wysokości drzewa, balansujemy wysokością poddrzew - te wyższe
            zmniejszamy, niższe wydłużamy.
            
            Co ważne - rotacje nie zmieniają w żaden sposób kolejności elementów (relacja pomiędzy węzłami/sortowanie jest
            zachowane).
            <br/>
            <br/>
            Spis treści (kliknij, by nie scrollować ;]):
            <ul>
                <li><a href="#Lrotation">Rotacja w lewo</a></li>
                <li><a href="#Rrotation">Rotacja w prawo</a></li>
                <li><a href="#resume">Podsumowanie</a></li>
            </ul>
            <br/>
        </p>


        <section id="Lrotation">
            <p>
                <h4>Rotacja w lewo</h4>
                Załóżmy, że mamy poniższą sytuację
                <br/>
                <img class="imgRotations" src="../textimg/RBTimg/rotations/rotationL1.png" />
                <br/>
                Specjalnie użyliśmy tutaj innego kolorwania (oczywiście, niezgodnego z konwencją RBT), aby same czynności,
                które wykonujemy w ramach rotacji były czytelniejsze.
                <br/>
                Chcemy dokonać rotacji w lewo na węźle o kluczu "30". Węzeł ten zejdzie do swojego byłego lewego podrzewa.
                Dodatkowo "pociągnie" ze sobą swoje prawo podrzewo (które pójdzie do góry - zgodnie z linią drzewa),
                zatem teraz węzeł o kluczu "30" będzie lewym dzieckiem węzła o kluczu "40".
                <br/>
                <img class="imgRotations" src="../textimg/RBTimg/rotations/rotationL2.png" />
                <br/>
                No dobrze, ale co się stanie z pozostałymi węzłami?
                <br/>
                Zacznijmy od węzła o kluczu "35". Przed operacją rotacji w lewo ten węzeł był lewym dzieckiem węzła o kluczu
                "40".
                Czy nadal może nim być? Nie, ponieważ ma już swoje lewe dziecko - węzeł o kluczu "30".
                <br/>
                Czy może być zatem prawym dzieckiem węzła o kluczu "40"? Nie, ponieważ zaburzylibyśmy regułę drzewa BST.
                <br/>
                <i class="red">
                    Pamiętasz tę regułę? klucz lewego dziecka &lt klucz rodzica &lt klucz prawego dziecka
                </i>
                <br/>
                To co powinniśmy zrobić? Odpowiedź jest dosyć prosta - dołączmy węzeł o kluczu "35" jako prawe dziecko węzła
                o kluczu "30".
                <br/>
                <img class="imgRotations" src="../textimg/RBTimg/rotations/rotationL3.png" />
                <br/>
                Co z pozostałymi węzłami? Dołączamy je bez zmian.
                <br/>
                <img class="imgRotations" src="../textimg/RBTimg/rotations/rotationL4.png" />
                <br/>
                Sprawdź, czy zostały zachowane właściwości BST (tak, BST - do drzewa czerwono-czarnego wrócimy w operacjach
                na tym drzewku).
                <br/>
                <img class="imgRotations" src="../textimg/RBTimg/rotations/rotationL.gif" />
            </p>
        </section>




        <section id="Rrotation">
            <p>
                <h4>Rotacja w prawo</h4>
                <br/>
                Rotacja w prawo jest symetrycznym odpowiednikiem rotacji w lewo. Skorzystamy z powyższego przykładu po
                rotacji w prawo -
                czyli po operacji rotacji w prawo wrócimy do punktu wyjściowego.
                <br/>
                <img class="imgRotations" src="../textimg/RBTimg/rotations/rotationR1.png" />
                <br/>
                Chcemy dokonać rotacji w lewo na węźle o kluczu "40". Węzeł ten zejdzie do swojego byłego prawego podrzewa.
                Dodatkowo "pociągnie" ze sobą swoje lewe podrzewo (które pójdzie do góry - zgodnie z linią drzewa),
                zatem teraz węzeł o kluczu "40" będzie prawym dzieckiem węzła o kluczu "30".
                <br/>
                <img class="imgRotations" src="../textimg/RBTimg/rotations/rotationR2.png" />
                <br/>
                Jak już się pewnie domyślasz, węzeł o kluczu "35" będzie lewym dzieckiem węzła o kluczu "40".
                <br/>
                <img class="imgRotations" src="../textimg/RBTimg/rotations/rotationR3.png" />
                <br/>
                A resztę węzłów podpinamy bez zmian.
                <br/>
                <img class="imgRotations" src="../textimg/RBTimg/rotations/rotationR4.png" />
                <br/>
                Tak samo - sprawdź, czy zostały zachowane właściwości BST.
                <br/>
                <img class="imgRotations" src="../textimg/RBTimg/rotations/rotationR.gif" />
            </p>
        </section>

        <section id="resume">
            <p>
                <h4>Podsumowanie</h4>
                Widzisz podobieństwa? Jakieś analogie? Podpowiemy Ci:
                <ul>
                    <li>Kiedy rotujesz węzeł w lewo, jego lewego wnuka podpinasz z prawej strony</li>
                    <li>Kiedy rotujesz węzeł w prawo, jego prawego wnuka podpinasz z lewej strony</li>
                </ul>
                W obu przykładach wnukiem był węzeł o kluczu "35".
                <br/>
                Boli Cię głowa od tych rotacji? Zrób sobie kawę, kilka przysiadów, weź 10 głębokich wdechów i lećmy dalej! Insertions - we're coming!
            </p>
        </section>

        <a href="#up">Powrót do góry</a>
    </div>
</div>

<div class="search">	
	 <div class="intro">
        <h3><u>Wyszukiwanie węzła o zadanym kluczu</u></h3>
        <p>
            Jeśli chodzi o wyszukiwanie węzła o zadanym kluczu, to przebiega ono dokładnie tak samo, jak w BST.
            Krótkie przypomnienie...
            <br/>
            <br/>
            Spis treści (kliknij, by nie scrollować ;]):
            <ul>
                <li><a href="#exists">Przypadek pozytywny - węzeł istnieje</a></li>
                <li><a href="#notexists">Przypadek negatywny - węzeł nie istnieje</a></li>
            </ul>
            <br/>
        </p>


        <section id="exists">
            <p>
                <h4>Przypadek pozytywny - węzeł istnieje</h4>
                Mamy poniższe RBT:
                <br/>
                <img class="imgSearch" src="../textimg/RBTimg/search/search_init.png"/>
                <br/>
                Chcemy w nim wyszukać węzła o kluczu "11". My widzmy, że istnieje taki węzeł. Komputer musi wykonać następujący ciąg instrukcji:
                <ul>
                    <li>Jesteśmy w węźle o kluczu "6". Czy jest to węzeł o kluczu "11"? Nie</li>
                    <li>Podejmuje decyzję, gdzie iść. 11 &lt 6? Nie. 11 &gt 6? Tak, idziemy w prawo.</li>
                </ul>
                <br/>
                <img class="imgSearch" src="../textimg/RBTimg/search/search_ok1.png"/>
                <br/>
                <ul>
                    <li>Jesteśmy w węźle o kluczu "12". Czy jest to węzeł o kluczu "11"? Nie</li>
                    <li>Podejmuje decyzję, gdzie iść. 11 &lt 12? Tak. Tak, idziemy w lewo.</li>
                </ul>
                <br/>
                <img class="imgSearch" src="../textimg/RBTimg/search/search_ok2.png"/>
                <br/>
                <ul>
                    <li>Jesteśmy w węźle o kluczu "10". Czy jest to węzeł o kluczu "11"? Nie</li>
                    <li>Podejmuje decyzję, gdzie iść. 11 &lt 10? Nie. 11 &gt 10? Tak, idziemy w prawo.</li>
                </ul>
                <br/>
                <img class="imgSearch" src="../textimg/RBTimg/search/search_ok3.png"/>
                <br/>
                <ul>
                    <li>Jesteśmy w węźle o kluczu "11". Czy jest to węzeł o kluczu "11"? Tak :) Kończymy procedurę</li>
                </ul>
                <br/>
                <img class="imgSearch" src="../textimg/RBTimg/search/search_ok4.png"/>
                <br/>
                Małe podsumowanie całości:
                <br/>
                <img class="imgSearch" src="../textimg/RBTimg/search/search_ok.gif"/>
                <br/>

            </p>
        </section>


        <section id="notexists">
            <p>
                <h4>Przypadek negatywny - węzeł nie istnieje</h4>
                Korzystamy z tego samego drzewka. Chcemy w nim wyszukać węzła o kluczu "22". Tym razem widzmy, że nie istnieje taki węzeł. 
                Rozpoczynamy procedurę przeszukiwania:
                <ul>
                    <li>Jesteśmy w węźle o kluczu "6". Czy jest to węzeł o kluczu "22"? Nie</li>
                    <li>Podejmuje decyzję, gdzie iść. 22 &lt 6? Nie. 22 &gt 6? Tak, idziemy w prawo.</li>
                </ul>
                <br/>
                <img class="imgSearch" src="../textimg/RBTimg/search/search_bad1.png"/>
                <br/>
                <ul>
                    <li>Jesteśmy w węźle o kluczu "12". Czy jest to węzeł o kluczu "22"? Nie</li>
                    <li>Podejmuje decyzję, gdzie iść. 22 &lt 12? Nie. 22 &gt 12? Tak, idziemy w prawo.</li>
                </ul>
                <br/>
                <img class="imgSearch" src="../textimg/RBTimg/search/search_bad2.png"/>
                <br/>
                <ul>
                    <li>Jesteśmy w węźle o kluczu "23". Czy jest to węzeł o kluczu "22"? Nie</li>
                    <li>Podejmuje decyzję, gdzie iść. 22 &lt 23? Tak, powinniśmy iść w lewo, ale sprawdzamy, że jest tam tylko czarny liść,
                        zatem kończymy poszukiwania węzła o kluczu "23" z wynikiem negatywnym.</li>
                </ul>
                <br/>
                <img class="imgSearch" src="../textimg/RBTimg/search/search_bad3.png"/>
                <br/>
                Całość przedstawia się w następujący sposób:
                <br/>
                <img class="imgSearch" src="../textimg/RBTimg/search/search_bad.gif"/>
                <br/>
            </p>
        </section>
        
        <a href="#up">Powrót do góry</a>
    </div>
</div>

<div class="del">
	<div class="intro">
        <h3><u>Usuwanie węzła</u></h3>
        <p>
            Przy usuwaniu węzła musimy wziąć pod uwagę więcej przypadków, jednak sama operacja nie jest jakoś mega skomplikowana (jednak
            dużo będzie "rodzinnych" relacji, więc nie zrażaj się po zobaczeniu spisu treści - razem damy radę! ;] ).
            W związku tym, że drzewo czerwono-czarne jest "zaawansowaną" wersją binarnego drzewa przeszukiwań nasza strategia jest następująca:
            <ul>
                <li>Usuwamy węzeł, jak przy BST</li>
                <li>Naprawiamy naruszone właściwości drzewa czerwono-czarnego</li>
            </ul>
            Proste, prawda? Wiemy, że pamięć studenta jest bardziej ulotna niż RAM w komputerze (ba dum tsss - dobry suchar nie jest zły :] ),
            przypomnijmy sobie pewne pojęcia. Jeśli jesteś studentem-rodzynkiem i pamiętasz wszystko na tip-top, to skorzystaj ze spisu poniżej,
            aby dotrzeć do interesujących Ciebie treści.
            <br/>
            <br/>
            Spis treści (kliknij, by nie scrollować ;]):
            <ul>
                <li><a href="#terms">Garść przydatnych pojęć</a></li>
                <li><a href="#remainder">Przypomnienie - usuwanie węzła w BST w pigułce</a></li>
                <li><a href="#BSTlike1">Usuwanie w stylu BST - przypadek 1 - usuwany węzeł ma tylko lewego syna</a></li>
                <li><a href="#BSTlike2">Usuwanie w stylu BST - przypadek 2 - usuwany węzeł ma tylko prawego syna</a></li>
                <li><a href="#BSTlike3">Usuwanie w stylu BST - przypadek 3 - usuwany węzeł posiada dwóch potomków i prawy jest jego następnikiem</a></li>
                <li><a href="#BSTlike4">Usuwanie w stylu BST - przypadek 4 - usuwany węzeł posiada dwóch potomków, ale prawy nie jest jego następnikiem</a></li>
                <li><a href="#repair1">Naprawa RBT - przypadek 1 - brat węzła zastępującego jest czerwony</a></li>
                <li><a href="#repair2">Naprawa RBT - przypadek 2 - brat węzła zastępującego jest czarny i ma czarnych synów</a></li>
                <li><a href="#repair3">Naprawa RBT - przypadek 3 - brat węzła zastępującego jest czarny, lewy syn brata czerwony i prawy czarny</a></li>
                <li><a href="#repair4">Naprawa RBT - przypadek 4 - brat węzła zastępującego jest czarny i jego prawy syn czerwony</a></li>
            </ul>
            <br/>
        </p>


        <section id="terms">
            <p>
                <h4>Garść przydatnych pojęć</h4>
                Będą nam teraz potrzebne takie pojęcia jak:
                <br/>
                <ul>
                    <li>
                        <b>Poprzednik</b> - jest to węzeł o kluczu bezpośrednio mniejszym od klucza wskazanego węzła.
                        W poniższym drzewie binarnym poprzednikiem węzła o kluczu "41" jest węzeł o kluczu "32". Jak go znaleźć?
                        To proste! Idziemy od węzła o kluczu "41" do lewego syna, a później maksymalnie w prawo. Ostatni węzeł niebędący liściem
                        jest poprzednikiem.
                        <br/>
                        <img class="imgDelete" src="img/delete/termsPred.gif" />
                        <br/>

                    </li>
                    <li>
                        <b>Następnik</b> - (analogicznie) jest to węzeł o kluczu bezpośrednio większym od klucza wskazanego węzła.
                        W poniższym drzewie binarnym następnikiem węzła o kluczu "41" jest węzeł o kluczu "50". Jak go znaleźć?
                        To proste! Idziemy od węzła o kluczu "41" do prawego syna, a później maksymalnie w lewo. Ostatni węzeł niebędący liściem
                        jest następnikiem.
                        <br/>
                        <img class="imgDelete" src="img/delete/termsSuc.gif" />
                        <br/>
                    </li>
                </ul>
                <br/>
            </p>
        </section>


        <section id="remainder">
            <p>
                <h4>Przypomnienie - usuwanie węzła w BST w pigułce</h4>
                <br/>
                <ul>
                    <li>
                        Jeśli węzeł nie ma dzieci, to możemy go zwyczajnie usunąć.
                        <br/>
                        <img class="imgDelete" src="img/delete/reminder1.gif" />
                        <br/>
                    </li>
                    <li>
                        Jeśli węzeł ma 1 potomka (lewego lub prawego), to on zastępuje usuwany węzeł.
                        <br/>
                        <div class="parallel">
                            <img class="imgDelete imgDelete2inRow" src="img/delete/reminder2L.gif" />
                        </div>
                        <div class="parallel">
                            <img class="imgDelete imgDelete2inRow" src="img/delete/reminder2R.gif" />
                        </div>
                        <div class="below"></div>
                    </li>
                    <li>
                        Jeśli węzeł ma obu potomków, to zastępujemy usuwany węzeł albo poprzednikiem, albo następnikiem (Twój wybór ;]).
                        <br/>
                        <div class="parallel">
                            <img class="imgDelete imgDelete2inRow" src="img/delete/reminder3L.gif" />
                        </div>
                        <div class="parallel">
                            <img class="imgDelete imgDelete2inRow" src="img/delete/reminder3R.gif" />
                        </div>
                        <div class="below"></div>
                    </li>
                    <li>
                        Jeśli poprzednik/następnik ma dziecko, to to dziecko zastępuje poprzednika/następnika, gdy ten zastąpi usuwany węzeł.
                        <br/>
                        <div class="parallel">
                            <img class="imgDelete imgDelete2inRow" src="img/delete/reminder4L.gif" />
                        </div>
                        <div class="parallel">
                            <img class="imgDelete imgDelete2inRow" src="img/delete/reminder4R.gif" />
                        </div>
                        <div class="below"></div>
                    </li>
                </ul>
            </p>
        </section>


       <section id="BSTlike1">
            <p>
                <h4>Usuwanie w stylu BST - przypadek 1 - usuwany węzeł ma tylko lewego syna</h4>
                <br/>
                Załóżmy, że mamy takie drzewko czerwono-czarne.
                <br/>
                <img class="imgDelete" src="img/delete/BSTlike1_0.png" />
                <br />
                Chcemy usunąć węzeł o kluczu "14". Usuwamy go jak w BST. W jego miejsce wchodzi jego lewy potomek.
                <br/>
                <img class="imgDelete" src="img/delete/BSTlike1_part.gif" />
                <br/>
                Jak widać, mamy konflikt - czerwony węzeł nie może mieć czewronych dzieci. Aby to naprawić dziecko usuniętego węzła przejmuje
                również po nim kolor. Jeśli usuwany węzeł był czarny, to musimy przekolorować dziecko na czarno.
                <br/>
                <img class="imgDelete" src="img/delete/BSTlike1_recolor.gif" />
                <br/>
                Gotowe!
                <br/>
                <img class="imgDelete" src="img/delete/BSTlike1_full.gif" />
                <br/>
            </p>
        </section>

        <section id="BSTlike2">
            <p>
                <h4>Usuwanie w stylu BST - przypadek 2 - usuwany węzeł ma tylko prawego syna</h4>
                <br/>
                Jest to lustrzany przypadek do poprzedniego, więc w poniższym drzewku spróbuj sama/sam usunąć węzeł o kluczu "14", np. na kartce.
                Jak skończysz - wróć do tego opracowania.
                <br/>
                <img class="imgDelete" src="img/delete/BSTlike2_0.png" />
                <br/>
                Usuwamy węzeł o kluczu "14" jak w BST - zastępujemy "dziurę" jego prawym potomkiem.
                <br/>
                <img class="imgDelete" src="img/delete/BSTlike2_part.gif" />
                <br/>
                Konflikt - zmieniamy kolor węzła-potomka, ale to już wiesz, prawda?
                <br/>
                <img class="imgDelete" src="img/delete/BSTlike2_recolor.gif" />
                <br/>
                Miałaś/miałeś tak samo? Gratulacje!
                <br/>
                <img class="imgDelete" src="img/delete/BSTlike2_full.gif" />
                <br/>
            </p>
        </section>

        <section id="BSTlike3">
            <p>
                <h4>Usuwanie w stylu BST - przypadek 3 - usuwany węzeł posiada dwóch potomków i prawy jest jego następnikiem</h4>
                <br/>
                W tym przypadku miejsce usuwanego węzła zajmuje jego następnik. Po usunięciu węzła następuje przekolorowanie. Sam następnik
                otrzymuje kolor węzła usuwanego. Sprawdźmy to na przykładzie.
                <br/>
                <img class="imgDelete" src="img/delete/BSTlike3_0.png" />
                <br/>
                Mamy takie drzewko i chcemy usunąć węzeł o kluczu "18".
                <br/>
                <img class="imgDelete" src="img/delete/BSTlike3_delete&recolor.gif" />
                <br/>
                Okej, usunęliśmy i zrobiliśmy przekolorowanie. Pytanie, czy wszystkie właściwości drzewa RBT zostały zachowane?
                Podpowiemy - nie. Jest o 1 czarny węzeł mniej, co za tym idzie już nie każda ścieżka z dowolnego węzła do liścia ma taką samą ilość
                czarnych węzłów. Aby to naprawić, prawy potomek następnika otrzyma dodatkowy kolor - taki, jakiego był następnik
                przed przekolorowaniem.
                <br/>
                <img class="imgDelete" src="img/delete/BSTlike3_colorBalance.gif" />
                <br/>
                Podwójny kolor czarny lub czerwono-czarność danego węzła zostanie naprawiona w przypadkach dotyczących napraw RBT.
            </p>
        </section>


        <section id="BSTlike4">
            <p>
                <h4>Usuwanie w stylu BST - przypadek 4 - usuwany węzeł posiada dwóch potomków, ale prawy nie jest jego następnikiem</h4>
                <br/>
                Mamy mniej więcej taką sytuację
                <br/>
                <img class="imgDelete" src="img/delete/BSTlike4_0.png" />
                <br/>
                Chcemy węzeł x usunąć z drzewka. W jego miejsce wchodzi następnik x3, a w miejsce następnika x3 wchodzi jego prawy potomek x4.
                Reszta zostaje bez zmian. Co z kolorami? Zasady są następujące:
                <ul>
                    <li>nastepnik x3 przejmuje kolor po usuniętym węźle x</li>
                    <li>jeśli następnik x3 był czarny, to węzeł x4 dostaje dodatkowy kolor czarny i jest teraz podwójnie czarny</li>
                    <li>jeśli następnik x3 był czerwony, to węzeł x4 dostaje dodatkowy kolor czerwony i jest teraz czerwono-czarny</li>
                </ul>
                Dwie ostatnie sytuacje są rozwiązywane w pozostałych przypadkach, które dotyczą naprawy RBT.
                <br/>
                <img class="imgDelete" src="img/delete/BSTlike4_full.gif" />
                <br/>
            </p>
        </section>

        <section id="repair1">
            <p>
                <h4>Naprawa RBT - przypadek 1 - brat węzła zastępującego jest czerwony</h4>
                <br/>
                <i class="red">
                    Uwaga! Wprowadzamy pewną konwencję w grafikach i w nazewnictwie, która obowiązuje tylko do poniższych przypadków.
                    <ul>
                        <li>Jeśli jego nazwa będzie z *, to oznacza, że dany węzeł posiada dodatkowy kolor</li>
                        <li>Jeśli węzeł jest szary, to oznacza, że może być czarny lub czerwony</li>
                    </ul>
                </i>
                <br/>
                Mamy taki przypadek
                <br/>
                <img class="imgDelete" src="img/delete/BSTrepair1_0.png" />
                <br/>
                Rotujemy węzeł x1 w lewo. Następnie zamieniamy kolory węzłów x1 i x2.
                <br/>
                <img class="imgDelete" src="img/delete/BSTrepair1_4.png" />
                <br/>
                Dalej sytuacja się rozstrzyga na podstawie kolorów węzłów potomnych od brata x*, czyli x3.
                <br/>
                <img class="imgDelete" src="img/delete/BSTrepair1.gif" />
                <br/>
            </p>
        </section>

        <section id="repair2">
            <p>
                <h4>Naprawa RBT - przypadek 2 - brat węzła zastępującego jest czarny i ma czarnych synów</h4>
                <br/>
                Nasz punkt startowy:
                <br>
                <img class="imgDelete" src="img/delete/BSTrepair2_0.png" />
                <br/>
                Zabieramy z węzłów x* i x2 kolor czarny i przenosimy go w górę, do węzła x1. 
                <br>
                <img class="imgDelete" src="img/delete/BSTrepair2_2.png" />
                <br/>
                W wyniku takiej operacji, węzeł x staje się normalnym węzłem czerwonym lub czarnym (w zależności, czy był czerwono-czarny,
                czy podwójnie czarny),a węzeł x2 staje się czerwony (jego potomkowie są czarni, więc nie naruszami struktury drzewa RBT).
                Niestety, skoro teraz węzeł x1* posiada dodatkowy kolor, to musimy wykonać procedurę naprawy rekurencyjnie w górę drzewka.
                <br>
                <img class="imgDelete" src="img/delete/BSTrepair2.gif" />
                <br/>
            </p>
        </section>

        <section id="repair3">
            <p>
                <h4>Naprawa RBT - przypadek 3 - brat węzła zastępującego jest czarny, lewy syn brata czerwony i prawy czarny</h4>
                <br/>
                <img class="imgDelete" src="img/delete/BSTrepair3_0.png" />
                <br/>
                Wykonujemy następujące kroki:
                <ol>
                    <li>Rotujemy węzeł x2 w prawo</li>
                    <li>Zamieniamy kolory węzłów między x2 a x3</li>
                </ol>
                Następnie przechodzimy do przypadku 4.
                <br>
                <img class="imgDelete" src="img/delete/BSTrepair3.gif" />
                <br/>
            </p>
        </section>

        <section id="repair4">
            <p>
                <h4>Naprawa RBT - przypadek 4 - brat węzła zastępującego jest czarny i jego prawy syn czerwony</h4>
                <br/>
                <img class="imgDelete" src="img/delete/BSTrepair4_0.png" />
                <br/>
                Wykonujemy następujące kroki:
                <ol>
                    <li>Rotujemy węzeł x1 w lewo</li>
                    <li>x1 oddaje swój kolor x2 - staje się przez chwilę bez koloru, przezroczysty</li>
                    <li>x* oddaje swój nadmiarowy kolor x1 - x1 staje się czarnym węzłem</li>
                    <li>na koniec kolorujemy x4 na czarno</li>
                </ol>
                Taka procedura w końcu kończy naprawianie drzewka czerwono-czarnego po usunięciu węzła.
                <br>
                <img class="imgDelete" src="img/delete/BSTrepair4.gif" />
                <br/>
            </p>
        </section>

        <a href="#up">Powrót do góry</a>
    </div>
</div>
</body>

</html>