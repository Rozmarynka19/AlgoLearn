<!DOCTYPE html>
<html>
    <head>
        <script language="javascript">
            function renev()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                //    if(p.className == "insert" || p.className == "rotacje" || p.className == "search" || p.className == "wprowadzenie" || p.className == "del"){
                //        p.hidden = true;
                //    }
                    p.hidden = true;
               }
              alert('test');
           
            }
            function listClass_CPP()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "listClass_CPP"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function nodeClass_CPP()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "nodeClass_CPP"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function insert_CPP()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "insert_CPP"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function search_CPP()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "search_CPP"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function delete_CPP()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "delete_CPP"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }

            function listClass_Java()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "listClass_Java"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function nodeClass_Java()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "nodeClass_Java"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function insert_Java()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "insert_Java"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function search_Java()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "search_Java"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function delete_Java()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "delete_Java"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            
            function listClass_PY()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "listClass_PY"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function nodeClass_PY()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "nodeClass_PY"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function insert_PY()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "insert_PY"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function search_PY()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "search_PY"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function delete_PY()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "delete_PY"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            </script>
	<style>
		body
		{
			font-weight: bold;
		}
	</style>
    </head>
    <body>
        <!-- C++ -->

        <div class="listClass_CPP">
            <pre>
// Class for Skip list 
class SkipList 
{ 
	// Maximum level for this skip list 
	int MAXLVL; 

	// P is the fraction of the nodes with level 
	// i pointers also having level i+1 pointers 
	float P; 

	// current level of skip list 
	int level; 

	// pointer to header node 
	Node *header; 
public: 
	SkipList(int, float); 
	int randomLevel(); 
	Node* createNode(int, int); 
	void insertElement(int); 
	void deleteElement(int); 
	void searchElement(int); 
	void displayList(); 
};

SkipList::SkipList(int MAXLVL, float P) 
{ 
	this->MAXLVL = MAXLVL; 
	this->P = P; 
	level = 0; 

	// create header node and initialize key to -1 
	header = new Node(-1, MAXLVL); 
}; 

// create random level for node 
int SkipList::randomLevel() 
{ 
	float r = (float)rand()/RAND_MAX; 
	int lvl = 0; 
	while(r &lt; P && lvl &lt; MAXLVL) 
	{ 
		lvl++; 
		r = (float)rand()/RAND_MAX; 
	} 
	return lvl; 
}; 

// create new node 
Node* SkipList::createNode(int key, int level) 
{ 
	Node *n = new Node(key, level); 
	return n; 
}; 

// Display skip list level wise 
void SkipList::displayList() 
{ 
	cout&lt;&lt;"\n*****Skip List*****"&lt;&lt;"\n"; 
	for(int i=0;i&lt;=level;i++) 
	{ 
		Node *node = header->forward[i]; 
		cout&lt;&lt;"Level "&lt;&lt;i&lt;&lt;": "; 
		while(node != NULL) 
		{ 
			cout&lt;&lt;node->key&lt;&lt;" "; 
			node = node->forward[i]; 
		} 
		cout&lt;&lt;"\n"; 
	} 
}; 
            </pre>
        </div>

        <div class="nodeClass_CPP">
            <pre>
// Class to implement node 
class Node 
{ 
public: 
	int key; 

	// Array to hold pointers to node of different level 
	Node **forward; 
	Node(int, int); 
}; 

Node::Node(int key, int level) 
{ 
	this->key = key; 

	// Allocate memory to forward 
	forward = new Node*[level+1]; 

	// Fill forward array with 0(NULL) 
	memset(forward, 0, sizeof(Node*)*(level+1)); 
}; 
            </pre>
        </div>

        <div class="insert_CPP">
            <pre>
// Insert given key in skip list 
void SkipList::insertElement(int key) 
{ 
	Node *current = header; 

	// create update array and initialize it 
	Node *update[MAXLVL+1]; 
	memset(update, 0, sizeof(Node*)*(MAXLVL+1)); 

	/* start from highest level of skip list 
		move the current pointer forward while key 
		is greater than key of node next to current 
		Otherwise inserted current in update and 
		move one level down and continue search 
	*/
	for(int i = level; i >= 0; i--) 
	{ 
		while(current->forward[i] != NULL && 
			current->forward[i]->key &lt; key) 
			current = current->forward[i]; 
		update[i] = current; 
	} 

	/* reached level 0 and forward pointer to 
	right, which is desired position to 
	insert key. 
	*/
	current = current->forward[0]; 

	/* if current is NULL that means we have reached 
	to end of the level or current's key is not equal 
	to key to insert that means we have to insert 
	node between update[0] and current node */
	if (current == NULL || current->key != key) 
	{ 
		// Generate a random level for node 
		int rlevel = randomLevel(); 

		/* If random level is greater than list's current 
		level (node with highest level inserted in 
		list so far), initialize update value with pointer 
		to header for further use */
		if(rlevel > level) 
		{ 
			for(int i=level+1;i&lt;rlevel+1;i++) 
				update[i] = header; 

			// Update the list current level 
			level = rlevel; 
		} 

		// create new node with random level generated 
		Node* n = createNode(key, rlevel); 

		// insert node by rearranging pointers 
		for(int i=0;i&lt;=rlevel;i++) 
		{ 
			n->forward[i] = update[i]->forward[i]; 
			update[i]->forward[i] = n; 
		} 
		cout&lt;&lt;"Successfully Inserted key "&lt;&lt;key&lt;&lt;"\n"; 
	} 
}; 
            </pre>
        </div>

        <div class="delete_CPP">
            <pre>
// Delete element from skip list 
void SkipList::deleteElement(int key) 
{ 
	Node *current = header; 

	// create update array and initialize it 
	Node *update[MAXLVL+1]; 
	memset(update, 0, sizeof(Node*)*(MAXLVL+1)); 

	/* start from highest level of skip list 
		move the current pointer forward while key 
		is greater than key of node next to current 
		Otherwise inserted current in update and 
		move one level down and continue search 
	*/
	for(int i = level; i >= 0; i--) 
	{ 
		while(current->forward[i] != NULL && 
			current->forward[i]->key &lt; key) 
			current = current->forward[i]; 
		update[i] = current; 
	} 

	/* reached level 0 and forward pointer to 
	right, which is possibly our desired node.*/
	current = current->forward[0]; 

	// If current node is target node 
	if(current != NULL and current->key == key) 
	{ 
		/* start from lowest level and rearrange 
		pointers just like we do in singly linked list 
		to remove target node */
		for(int i=0;i&lt;=level;i++) 
		{ 
			/* If at level i, next node is not target 
			node, break the loop, no need to move 
			further level */
			if(update[i]->forward[i] != current) 
				break; 

			update[i]->forward[i] = current->forward[i]; 
		} 

		// Remove levels having no elements 
		while(level>0 && 
			header->forward[level] == 0) 
			level--; 
		cout&lt;&lt;"Successfully deleted key "&lt;&lt;key&lt;&lt;"\n"; 
	} 
}; 
            </pre>
        </div>

        <div class="search_CPP">
            <pre>
// Search for element in skip list 
void SkipList::searchElement(int key) 
{ 
	Node *current = header; 

	/* start from highest level of skip list 
		move the current pointer forward while key 
		is greater than key of node next to current 
		Otherwise inserted current in update and 
		move one level down and continue search 
	*/
	for(int i = level; i >= 0; i--) 
	{ 
		while(current->forward[i] && 
			current->forward[i]->key &lt; key) 
			current = current->forward[i]; 

	} 

	/* reached level 0 and advance pointer to 
	right, which is possibly our desired node*/
	current = current->forward[0]; 

	// If current node have key equal to 
	// search key, we have found our target node 
	if(current and current->key == key) 
		cout&lt;&lt;"Found key: "&lt;&lt;key&lt;&lt;"\n"; 
}; 
            </pre>
        </div>

        <!-- Java -->

        <div class="listClass_Java">
            <pre>
public class SkipList {
	// Maximum level for this skip list 
		private int MAXLVL; 

		// P is the fraction of the nodes with level 
		// i pointers also having level i+1 pointers 
		private float P; 

		// current level of skip list 
		private int level; 

		// pointer to header node 
		private Node header; 
	    public SkipList(int MAXLVL, float P)
	    { 
	        this.MAXLVL = MAXLVL; 
	        this.P = P; 
	        level = 0; 
	    
	        // create header node and initialize key to -1 
	        header = new Node(-1, MAXLVL); 
	    }; 
	    public int randomLevel()
	    { 
	        float r = (float)Math.random(); 
	        int lvl = 0; 
	        while(r &lt; P && lvl &lt; MAXLVL) 
	        { 
	            lvl++; 
	            r = (float)Math.random();
	        } 
	        return lvl; 
	    }; 
	    public Node createNode(int key, int level)
	    { 
	        Node n = new Node(key, level); 
	        return n; 
	    };  
	    public void insertElement(int key)
	    { ... }; 
		public void deleteElement(int key)
	    { ... };
		public void searchElement(int key) 
	    { ... };
}
            </pre>
        </div>

        <div class="nodeClass_Java">
            <pre>
public class Node {
	public int key; 

	// Array to hold pointers to node of different level 
	public Node[] forward; 
    public Node(int key, int level) 
    { 
        this.key = key; 
    
        // Allocate memory to forward 
        forward = new Node[level+1]; 
    
        // Fill forward array with 0(NULL) 
        for(int i=0;i&lt;level+1;i++)
        	forward[i]=null;
    };
}
            </pre>
        </div>

        <div class="insert_Java">
            <pre>
public void insertElement(int key)
{ 
    Node current = header; 

    // create update array and initialize it 
    Node[] update = new Node[MAXLVL+1];
    for(int i=0;i&lt;MAXLVL+1;i++)
        update[i]=null;

    /* start from highest level of skip list 
        move the current pointer forward while key 
        is greater than key of node next to current 
        Otherwise inserted current in update and 
        move one level down and continue search 
    */
    for(int i = level; i >= 0; i--) 
    { 
        while(current.forward[i] != null && 
            current.forward[i].key &lt; key) 
            current = current.forward[i]; 
        update[i] = current; 
    } 

    /* reached level 0 and forward pointer to 
    right, which is desired position to 
    insert key. 
    */
    current = current.forward[0]; 

    /* if current is NULL that means we have reached 
    to end of the level or current's key is not equal 
    to key to insert that means we have to insert 
    node between update[0] and current node */
    if (current == null || current.key != key) 
    { 
        // Generate a random level for node 
        int rlevel = randomLevel(); 

        /* If random level is greater than list's current 
        level (node with highest level inserted in 
        list so far), initialize update value with pointer 
        to header for further use */
        if(rlevel > level) 
        { 
            for(int i=level+1;i&lt;rlevel+1;i++) 
                update[i] = header; 

            // Update the list current level 
            level = rlevel; 
        } 

        // create new node with random level generated 
        Node n = createNode(key, rlevel); 

        // insert node by rearranging pointers 
        for(int i=0;i&lt;=rlevel;i++) 
        { 
            n.forward[i] = update[i].forward[i]; 
            update[i].forward[i] = n; 
        } 
        System.out.println("Successfully Inserted key "+String.valueOf(key));
    } 
}; 
            </pre>
        </div>

        <div class="delete_Java">
            <pre>
public void deleteElement(int key)
{ 
    Node current = header; 

    // create update array and initialize it 
    Node[] update = new Node[MAXLVL+1]; 
    for(int i=0;i&lt;MAXLVL+1;i++)
        update[i]=null;

    /* start from highest level of skip list 
        move the current pointer forward while key 
        is greater than key of node next to current 
        Otherwise inserted current in update and 
        move one level down and continue search 
    */
    for(int i = level; i >= 0; i--) 
    { 
        while(current.forward[i] != null && 
            current.forward[i].key &lt; key) 
            current = current.forward[i]; 
        update[i] = current; 
    } 

    /* reached level 0 and forward pointer to 
    right, which is possibly our desired node.*/
    current = current.forward[0]; 

    // If current node is target node 
    if(current != null && current.key == key) 
    { 
        /* start from lowest level and rearrange 
        pointers just like we do in singly linked list 
        to remove target node */
        for(int i=0;i&lt;=level;i++) 
        { 
            /* If at level i, next node is not target 
            node, break the loop, no need to move 
            further level */
            if(update[i].forward[i] != current) 
                break; 

            update[i].forward[i] = current.forward[i]; 
        } 

        // Remove levels having no elements 
        while(level>0 && header.forward[level] == null) 
            level--; 
        System.out.println("Successfully deleted key "+String.valueOf(key));
    } 
};
            </pre>
        </div>
        
        <div class="search_Java">
            <pre>
public void searchElement(int key) 
{ 
    Node current = header; 

    /* start from highest level of skip list 
        move the current pointer forward while key 
        is greater than key of node next to current 
        Otherwise inserted current in update and 
        move one level down and continue search 
    */
    for(int i = level; i >= 0; i--) 
    { 
        while(current.forward[i] != null && 
            current.forward[i].key &lt; key) 
            current = current.forward[i]; 

    } 

    /* reached level 0 and advance pointer to 
    right, which is possibly our desired node*/
    current = current.forward[0]; 

    // If current node have key equal to 
    // search key, we have found our target node 
    if(current!=null && current.key == key)
        System.out.println("Found key: "+String.valueOf(key));
}; 
            </pre>
        </div>


        <!-- Python -->

        <div class="listClass_PY">
            <pre>
class SkipList(object): 
    def __init__(self, max_lvl, P): 
        # Maximum level for this skip list 
        self.MAXLVL = max_lvl 
  
        # P is the fraction of the nodes with level  
        # i references also having level i+1 references 
        self.P = P 
  
        # create header node and initialize key to -1 
        self.header = self.createNode(self.MAXLVL, -1) 
  
        # current level of skip list 
        self.level = 0
      
    # create  new node 
    def createNode(self, lvl, key): 
        n = Node(key, lvl) 
        return n 
      
    # create random level for node 
    def randomLevel(self): 
        lvl = 0
        while random.random()&lt;self.P and \ 
              lvl&lt;self.MAXLVL:lvl += 1
        return lvl 
  
    # insert given key in skip list 
    def insertElement(self, key): 
        ...
  
    def deleteElement(self, search_key): 
        ...
  
    def searchElement(self, key):  
        ...
  
  
    # Display skip list level wise 
    def displayList(self): 
        print("\n*****Skip List******") 
        head = self.header 
        for lvl in range(self.level+1): 
            print("Level {}: ".format(lvl), end=" ") 
            node = head.forward[lvl] 
            while(node != None): 
                print(node.key, end=" ") 
                node = node.forward[lvl] 
            print("") 
            </pre>
        </div>

        <div class="nodeClass_PY">
            <pre>
class Node(object):
    def __init__(self, key, level): 
        self.key = key 
  
        # list to hold references to node of different level  
        self.forward = [None]*(level+1) 
            </pre>
        </div>

        <div class="insert_PY">
            <pre>
def insertElement(self, key): 
    # create update array and initialize it 
    update = [None]*(self.MAXLVL+1) 
    current = self.header 

    ''' 
    start from highest level of skip list 
    move the current reference forward while key  
    is greater than key of node next to current 
    Otherwise inserted current in update and  
    move one level down and continue search 
    '''
    for i in range(self.level, -1, -1): 
        while current.forward[i] and \ 
                current.forward[i].key &lt; key: 
            current = current.forward[i] 
        update[i] = current 

    '''  
    reached level 0 and forward reference to  
    right, which is desired position to  
    insert key. 
    ''' 
    current = current.forward[0] 

    ''' 
    if current is NULL that means we have reached 
        to end of the level or current's key is not equal 
        to key to insert that means we have to insert 
        node between update[0] and current node 
    '''
    if current == None or current.key != key: 
        # Generate a random level for node 
        rlevel = self.randomLevel() 

        ''' 
        If random level is greater than list's current 
        level (node with highest level inserted in  
        list so far), initialize update value with reference 
        to header for further use 
        '''
        if rlevel > self.level: 
            for i in range(self.level+1, rlevel+1): 
                update[i] = self.header 
            self.level = rlevel 

        # create new node with random level generated 
        n = self.createNode(rlevel, key) 

        # insert node by rearranging references  
        for i in range(rlevel+1): 
            n.forward[i] = update[i].forward[i] 
            update[i].forward[i] = n 

        print("Successfully inserted key {}".format(key)) 
            </pre>
        </div>

        <div class="delete_PY">
            <pre>
def deleteElement(self, search_key): 

    # create update array and initialize it 
    update = [None]*(self.MAXLVL+1) 
    current = self.header 

    ''' 
    start from highest level of skip list 
    move the current reference forward while key  
    is greater than key of node next to current 
    Otherwise inserted current in update and  
    move one level down and continue search 
    '''
    for i in range(self.level, -1, -1): 
        while(current.forward[i] and \ 
                current.forward[i].key &lt; search_key): 
            current = current.forward[i] 
        update[i] = current 

    '''  
    reached level 0 and advance reference to  
    right, which is prssibly our desired node 
    ''' 
    current = current.forward[0] 

    # If current node is target node 
    if current != None and current.key == search_key: 

        ''' 
        start from lowest level and rearrange references  
        just like we do in singly linked list 
        to remove target node 
        '''
        for i in range(self.level+1): 

            ''' 
            If at level i, next node is not target  
            node, break the loop, no need to move  
            further level 
            '''
            if update[i].forward[i] != current: 
                break
            update[i].forward[i] = current.forward[i] 

        # Remove levels having no elements 
        while(self.level>0 and\ 
                self.header.forward[self.level] == None): 
            self.level -= 1
        print("Successfully deleted {}".format(search_key)) 
            </pre>
        </div>
        
        <div class="search_PY">
            <pre>
def searchElement(self, key):  
    current = self.header 

    ''' 
    start from highest level of skip list 
    move the current reference forward while key  
    is greater than key of node next to current 
    Otherwise inserted current in update and  
    move one level down and continue search 
    '''
    for i in range(self.level, -1, -1): 
        while(current.forward[i] and\ 
                current.forward[i].key &lt; key): 
            current = current.forward[i] 

    # reached level 0 and advance reference to  
    # right, which is prssibly our desired node 
    current = current.forward[0] 

    # If current node have key equal to 
    # search key, we have found our target node 
    if current and current.key == key: 
        print("Found key ", key) 
            </pre>
        </div>
    Na podstawie <a href="https://www.geeksforgeeks.org/skip-list-set-3-searching-deletion" target="_blank">GeekForGeeks - Skip List</a>
    </body>
</html>