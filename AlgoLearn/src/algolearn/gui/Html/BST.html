<html>
<head>
<script language="javascript">
 function renev()
 {
   var p_list = document.getElementsByTagName("div");
    for(var i=p_list.length-1; i>=0; i--){
        var p = p_list[i];
        if(p.className == "intro" || p.className == "insert" || p.className == "del" || p.className == "search"){
			p.hidden = true;
        }
    }
   alert('test');

 }
  function intro()
 {
   var p_list = document.getElementsByTagName("div");
    for(var i=p_list.length-1; i>=0; i--){
        var p = p_list[i];
        if(p.className == "intro"){
			p.hidden = false;
        }
    }
   alert('test');

 }
 function insert()
 {
   var p_list = document.getElementsByTagName("div");
    for(var i=p_list.length-1; i>=0; i--){
        var p = p_list[i];
        if(p.className == "insert"){
			p.hidden = false;
        }
    }
   alert('test');

 }
 function del()
 {
   var p_list = document.getElementsByTagName("div");
    for(var i=p_list.length-1; i>=0; i--){
        var p = p_list[i];
        if(p.className == "del"){
			p.hidden = false;
        }
    }
   alert('test');

 }
 function search()
 {
   var p_list = document.getElementsByTagName("div");
    for(var i=p_list.length-1; i>=0; i--){
        var p = p_list[i];
        if(p.className == "search"){
			p.hidden = false;
        }
    }
   alert('test');

 }
 </script>
    <meta charset="UTF-8">
    <style>
      h1 {text-align: center;}
      img
      {
        display: block;
        margin-left: auto;
        margin-right: auto;
        width:50%;
        height:50%;
      }
	  body.disabled { 
		pointer-events: none; 
		-webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; 
		user-select: none;
		}
		body.disabled *:focus { outline: 0; }
      </style>
</head>
<body class="disabled">

  
  <div class=intro>
    <h1>Binarne Drzewo Poszukiwań</h1>
    
    <img src="../textimg/BST/1.png"></img><br>
    
    Binarne drzewo poszukiwań to struktura danych oparta na tworzeniu połączeń każdego z węzłów z maksymalnie dwoma potomkami. 
    Lewy potomek jest zawszę mniejszy od rodzica, a prawy większy.<br>
    
    <img src="../textimg/BST/2.png"></img><br>
    
    Jak można zauważyć w lewym poddrzewie mieszczą się wszystkie wartości mniejsze od korzenia i analogiczni w prawym większe,
    co ułatwia przeszukiwanie wartości gdyż za pomocą jednego porównania można wykluczyć z poszukiwania nawet połowę z posiadanych wartości. <br>
    Powoduje to też że łatwo znaleźć największą wartość która będzie znajdować się na skrajnym prawym liściu i analogiczne najmniejszą.
  </div>

  <div class=search>
    <b>Szukanie</b>: aby wykonać dowolną operacje w drzewie najpierw trzeba znaleźć odpowiednie miejsce lub element. 
    Przeszukiwanie drzewa BST postępuje według schematu:<br>
    
    <img src="../textimg/BST/szukgood.gif"></img><br>
    
    Jeśli szukamy wartości 40 to najpierw porównujemy ją z korzeniem czyli 30 od którego jest większy, więc idziemy w prawo.
     Od prawego potomka 40 jest mniejsze więc idziemy w lewo. Przy pomocy przyrównania 40 = 40 odnajdujemy rzeczony element.<br>
    <img src="../textimg/BST/szukanie.gif"></img><br>
    W przypadku wartości która nie występuje w drzewie droga wygląda analogicznie oprócz ostatniego przypadku.
     Kiedy dochodzimy do 40 nie ma już możliwości przejścia do jego lewego potomka, oznacza to że w drzewie nie ma takiej wartości.<br><br>
  </div>

  <div class=insert>
    <b>Dodawanie wartości:</b> Aby dodać wartość najpierw musimy sprawdzić czy w drzewie nie ma jeszcze takiej wartości posługując się operacją szukania.
    Jeśli znaleźliśmy wartości dodajemy ją zgodnie z zasadą tworząc prawego lub lewego potomka. <br>
   <img src="../textimg/BST/dodawanie.gif"></img><br>
  </div>

  <div class=del>
    <b>Usuwanie wartości:</b> Problemy zaczynają się przy usuwaniu wartości. Jeśli wartość którą chcemy usunąć jest liściem to nie ma problemu, postępujemy jak w poprzednich przypadkach. Ale jeśli posiada potomków, albo co gorsza jest korzeniem to sprawa się komplikuje. W takim przypadku wybieramy wartość najbliższą usuwanej. W przypadku usunięcia 30 może to być 20 albo 39. Aby znaleźć takiego następce należy kierować się raz w prawo i cały czas w lewo aby znaleźć najbliższą większą wartość, albo raz w lewo i cały czas w prawo żeby znaleźć najbliższą mniejszą wartość. Jeśli szukana wartość również posiada potomka to postępujemy analogicznie szukając zastępcy.
    Nasuwa się tu więc rekurencyjne rozwiązanie problemu usuwania.<br>
    <img src="../textimg/BST/usuwanie.gif"></img>
  </div>

</body>
</html>