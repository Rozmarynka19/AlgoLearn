<!DOCTYPE html>
<html>
    <head>
        <script language="javascript">
            function renev()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                //    if(p.className == "insert" || p.className == "rotacje" || p.className == "search" || p.className == "wprowadzenie" || p.className == "del"){
                //        p.hidden = true;
                //    }
                    p.hidden = true;
               }
              alert('test');
           
            }
            function treeClass_CPP()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "treeClass_CPP"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function nodeClass_CPP()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "nodeClass_CPP"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function rotation_CPP()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "rotation_CPP"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function insert_CPP()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "insert_CPP"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function search_CPP()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "search_CPP"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function delete_CPP()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "delete_CPP"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }

            function treeClass_Java()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "treeClass_Java"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function nodeClass_Java()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "nodeClass_Java"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function rotation_Java()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "rotation_Java"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function insert_Java()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "insert_Java"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function search_Java()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "search_Java"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function delete_Java()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "delete_Java"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            
            function treeClass_PY()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "treeClass_PY"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function nodeClass_PY()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "nodeClass_PY"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function rotation_PY()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "rotation_PY"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function insert_PY()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "insert_PY"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function search_PY()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "search_PY"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            function delete_PY()
            {
              var p_list = document.getElementsByTagName("div");
               for(var i=p_list.length-1; i>=0; i--){
                   var p = p_list[i];
                   if(p.className == "delete_PY"){
                       p.hidden = false;
                   }
               }
              alert('test');
            }
            </script>
	<style>
		body
		{
			font-weight: bold;
		}
	</style>
    </head>
    <body>
        <!-- C++ -->

        <div class="treeClass_CPP">
            <pre>
template &lt;class T>
    class RedBlackTree
    {
    private:
        Node&lt;T> blackSentinelNode;
        Node&lt;T>* root;
        int nodeCounter;
    
        //Rotates child onto parent; child is right parent's child
        void rotateLeft(Node&lt;T>* child, Node&lt;T>* parent);
    
        //Rotates child onto parent; child is left parent's child
        void rotateRight(Node&lt;T> * child, Node&lt;T> * parent);
    
    public:
        RedBlackTree()
        {
            nodeCounter = 0;
    
            blackSentinelNode.left = &blackSentinelNode;
            blackSentinelNode.right = &blackSentinelNode;
            blackSentinelNode.parent = &blackSentinelNode;
            blackSentinelNode.isBlack = true;
    
            root = &blackSentinelNode;
        }
        ~RedBlackTree()
        {
            ReleaseNodes(root);
        }
    
        void Add(T data);
    
        //Returns pointer at node with the given key if succeed or NULL if failed
        Node&lt;T>* Find(T data);
    
        void Delete(T data);
    
        Node&lt;T>* getSuccessor(Node&lt;T>* node)
    }
            </pre>
        </div>

        <div class="nodeClass_CPP">
            <pre>
template &lt;class T>
    class Node
    {
        template &lt;class T> friend class RedBlackTree;
    
        Node&lt;T>* parent, * left, * right;
        T data;
        bool isBlack;
    
    public:
        Node() {}
        Node(T data)
        {
            this->data = data;
            this->isBlack = false;
        }
    };
            </pre>
        </div>

        <div class="insert_CPP">
            <pre>
void Add(T data)
{
    Node&lt;T>* newNode = addBST(data);
    Node&lt;T>* uncle;

    while ((newNode != root) && (newNode->parent->isBlack == false))
    {
        if (newNode->parent == newNode->parent->parent->left)
        {
            uncle = newNode->parent->parent->right;

            //uncle is red
            if (uncle->isBlack == false)
            {
                newNode->parent->isBlack = true;
                uncle->isBlack = true;
                newNode->parent->parent->isBlack = false;
                newNode = newNode->parent->parent;
                continue;
            }

            //triangle case
            if (newNode == newNode->parent->right)
            {
                newNode = newNode->parent;
                rotateLeft(newNode->right, newNode);
            }

            //linear case
            newNode->parent->isBlack = true;
            newNode->parent->parent->isBlack = false;
            rotateRight(newNode->parent, newNode->parent->parent);
            break;
        }
        else
        {
            uncle = newNode->parent->parent->left;

            if (uncle->isBlack == false)
            {
                newNode->parent->isBlack = true;
                uncle->isBlack = true;
                newNode->parent->parent->isBlack = false;
                newNode = newNode->parent->parent;
                continue;
            }

            if (newNode == newNode->parent->left)
            {
                newNode = newNode->parent;
                rotateRight(newNode->left, newNode);
            }

            newNode->parent->isBlack = true;
            newNode->parent->parent->isBlack = false;
            rotateLeft(newNode->parent, newNode->parent->parent);
            break;
        }
    }

    root->isBlack = true;
}
            </pre>
        </div>

        <div class="delete_CPP">
            <pre>
void Delete(T data)
{
    Node&lt;T>* X = Find(data);
    Node&lt;T> * W, * Y, * Z;

    if( ( X->left == &blackSentinelNode ) || ( X->right == &blackSentinelNode ) ) Y = X;
    else Y = getSuccessor ( X );

    if( Y->left != &blackSentinelNode ) Z = Y->left;
    else Z = Y->right;

    Z->parent = Y->parent;

    if( Y->parent == &blackSentinelNode ) root = Z;
    else if( Y == Y->parent->left ) Y->parent->left  = Z;
    else Y->parent->right = Z;

    if( Y != X ) X->data = Y->data;

    if( Y->isBlack)
    while( ( Z != root ) && ( Z->isBlack) )
        if( Z == Z->parent->left )
        {
        W = Z->parent->right;

        if( !W->isBlack )
        {
            W->isBlack = true;
            Z->parent->isBlack = false;
            rotateLeft ( Z->parent, Z->parent->parent );
            W = Z->parent->right;
        }

        if( ( W->left->isBlack) && ( W->right->isBlack) )
        {
            W->isBlack = false;
            Z = Z->parent;
            continue;
        }

        if( W->right->isBlack)
        {
            W->left->isBlack = true;
            W->isBlack = false;
            rotateRight ( W, W->parent );
            W = Z->parent->right;
        }

        W->isBlack = Z->parent->isBlack;
        Z->parent->isBlack = W->right->isBlack = true;
        rotateLeft ( Z->parent, Z->parent->parent );
        Z = root;
        }
        else
        {
        W = Z->parent->left;

        if( !W->isBlack)
        { 
            W->isBlack = true;
            Z->parent->isBlack = false;
            rotateRight ( Z->parent, Z->parent->parent );
            W = Z->parent->left;
        }

        if( ( W->left->isBlack) && ( W->right->isBlack) )
        { 
            W->isBlack = false;
            Z = Z->parent;
            continue;
        }

        if( W->left->isBlack)
        { 
            W->right->isBlack = true;
            W->isBlack = false;
            rotateLeft( W, W->parent );
            W = Z->parent->left;
        }

        W->isBlack = Z->parent->isBlack; 
        Z->parent->isBlack = true;
        W->left->isBlack = true;
        rotateRight ( Z->parent, Z->parent->parent );
        Z = root; 
        }

    Z->isBlack = true;

    delete Y;
}
            </pre>
        </div>

        <div class="rotation_CPP">
            <pre>
//Rotates child onto parent; child is right parent's child
void rotateLeft(Node&lt;T>* child, Node&lt;T>* parent)
{
    Node&lt;T>* grandparent;

    if (child != &blackSentinelNode)
    {
        grandparent = parent->parent;
        parent->right = child->left;
        if (parent->right != &blackSentinelNode) parent->right->parent = parent;

        child->left = parent;
        child->parent = grandparent;
        parent->parent = child;

        if (grandparent != &blackSentinelNode)
        {
            if (grandparent->right == parent) grandparent->right = child;
            else grandparent->left = child;
        }
        else root = child;
    }
}

//Rotates child onto parent; child is left parent's child
void rotateRight(Node&lt;T> * child, Node&lt;T> * parent)
{
    Node&lt;T>* grandparent;

    if (child != &blackSentinelNode)
    {
        grandparent = parent->parent;
        parent->left = child->right;
        if (parent->left != &blackSentinelNode) parent->left->parent = parent;

        child->right = parent;
        child->parent = grandparent;
        parent->parent = child;

        if (grandparent != &blackSentinelNode)
        {
            if (grandparent->right == parent)  grandparent->right = child;
            else grandparent->left = child;
        }
        else root = child;
    }
}
            </pre>
        </div>

        <div class="search_CPP">
            <pre>
//Returns pointer at node with the given key if succeed or NULL if failed
Node&lt;T>* Find(T data)
{
    Node&lt;T>* node = root;

    while ((node != &blackSentinelNode) && (node->data != data))
    {
        if (data > node->data) node = node->right;
        else node = node->left;
    }
    if (node == &blackSentinelNode) return NULL;

    return node;
}
            </pre>
        </div>

        <!-- Java -->

        <div class="treeClass_Java">
            <pre>
public class RedBlackTree&lt;T extends Comparable&lt;T>> {

    private Node&lt;T> blackSentinelNode;
    private Node&lt;T> root;
    private int nodeCounter;

    private void rotateLeft(Node&lt;T> child, Node&lt;T> parent){...}
    private void rotateRight(Node&lt;T> child, Node&lt;T> parent){...}

    public RedBlackTree()
    {
        nodeCounter=0;

        blackSentinelNode.left=blackSentinelNode;
        blackSentinelNode.right=blackSentinelNode;
        blackSentinelNode.parent=blackSentinelNode;
        blackSentinelNode.isBlack=true;

        root = blackSentinelNode;
    }
    public void Add(T data) {...}
    public Node&lt;T> Find(T data) {...}
    public void Delete (T data) {...}
    public Node&lt;T> getSuccessor(Node&lt;T> node) {...}


}
                
            </pre>
        </div>

        <div class="nodeClass_Java">
            <pre>
public class Node&lt;T extends Comparable&lt;T>>
    {
        public Node&lt;T> parent,left,right;
        public T data;
        public boolean isBlack;
        
        public Node() {}
        public Node(T data)
        {
            this.data=data;
            this.isBlack=false;
        }
    
    
    }
            </pre>
        </div>

        <div class="insert_Java">
            <pre>
public void Add(T data)
{
    Node&lt;T> newNode = addBST(data);
    Node&lt;T> uncle;

    while ((newNode != root) && (newNode.parent.isBlack == false))
    {
        if (newNode.parent == newNode.parent.parent.left)
        {
            uncle = newNode.parent.parent.right;

            //uncle is red
            if (uncle.isBlack == false)
            {
                newNode.parent.isBlack = true;
                uncle.isBlack = true;
                newNode.parent.parent.isBlack = false;
                newNode = newNode.parent.parent;
                continue;
            }

            //triangle case
            if (newNode == newNode.parent.right)
            {
                newNode = newNode.parent;
                rotateLeft(newNode.right, newNode);
            }

            //linear case
            newNode.parent.isBlack = true;
            newNode.parent.parent.isBlack = false;
            rotateRight(newNode.parent, newNode.parent.parent);
            break;
        }
        else
        {
            uncle = newNode.parent.parent.left;

            if (uncle.isBlack == false)
            {
                newNode.parent.isBlack = true;
                uncle.isBlack = true;
                newNode.parent.parent.isBlack = false;
                newNode = newNode.parent.parent;
                continue;
            }

            if (newNode == newNode.parent.left)
            {
                newNode = newNode.parent;
                rotateRight(newNode.left, newNode);
            }

            newNode.parent.isBlack = true;
            newNode.parent.parent.isBlack = false;
            rotateLeft(newNode.parent, newNode.parent.parent);
            break;
        }
    }

    root.isBlack = true;
}
            </pre>
        </div>

        <div class="delete_Java">
            <pre>
public void Delete(T data)
{
    Node&lt;T> X = Find(data);
    Node&lt;T>  W,  Y,  Z;

    if( ( X.left == blackSentinelNode ) || ( X.right == blackSentinelNode ) ) Y = X;
    else Y = getSuccessor ( X );

    if( Y.left != blackSentinelNode ) Z = Y.left;
    else Z = Y.right;

    Z.parent = Y.parent;

    if( Y.parent == blackSentinelNode ) root = Z;
    else if( Y == Y.parent.left ) Y.parent.left  = Z;
    else Y.parent.right = Z;

    if( Y != X ) X.data = Y.data;

    if( Y.isBlack)
    while( ( Z != root ) && ( Z.isBlack) )
        if( Z == Z.parent.left )
        {
        W = Z.parent.right;

        if( !W.isBlack )
        {
            W.isBlack = true;
            Z.parent.isBlack = false;
            rotateLeft ( Z.parent, Z.parent.parent );
            W = Z.parent.right;
        }

        if( ( W.left.isBlack) && ( W.right.isBlack) )
        {
            W.isBlack = false;
            Z = Z.parent;
            continue;
        }

        if( W.right.isBlack)
        {
            W.left.isBlack = true;
            W.isBlack = false;
            rotateRight ( W, W.parent );
            W = Z.parent.right;
        }

        W.isBlack = Z.parent.isBlack;
        Z.parent.isBlack = W.right.isBlack = true;
        rotateLeft ( Z.parent, Z.parent.parent );
        Z = root;
        }
        else
        {
        W = Z.parent.left;

        if( !W.isBlack)
        { 
            W.isBlack = true;
            Z.parent.isBlack = false;
            rotateRight ( Z.parent, Z.parent.parent );
            W = Z.parent.left;
        }

        if( ( W.left.isBlack) && ( W.right.isBlack) )
        { 
            W.isBlack = false;
            Z = Z.parent;
            continue;
        }

        if( W.left.isBlack)
        { 
            W.right.isBlack = true;
            W.isBlack = false;
            rotateLeft( W, W.parent );
            W = Z.parent.left;
        }

        W.isBlack = Z.parent.isBlack; 
        Z.parent.isBlack = true;
        W.left.isBlack = true;
        rotateRight ( Z.parent, Z.parent.parent );
        Z = root; 
        }

    Z.isBlack = true;

    Y = null;
}
            </pre>
        </div>

        <div class="rotation_Java">
            <pre>
//Rotates child onto parent; child is right parent's child
private void rotateLeft(Node&lt;T> child, Node&lt;T> parent)
{
    Node&lt;T> grandparent;

    if (child != blackSentinelNode)
    {
        grandparent = parent.parent;
        parent.right = child.left;
        if (parent.right != blackSentinelNode) parent.right.parent = parent;

        child.left = parent;
        child.parent = grandparent;
        parent.parent = child;

        if (grandparent != blackSentinelNode)
        {
            if (grandparent.right == parent) grandparent.right = child;
            else grandparent.left = child;
        }
        else root = child;
    }
}

//Rotates child onto parent; child is left parent's child
private void rotateRight(Node&lt;T>  child, Node&lt;T>  parent)
{
    Node&lt;T> grandparent;

    if (child != blackSentinelNode)
    {
        grandparent = parent.parent;
        parent.left = child.right;
        if (parent.left != blackSentinelNode) parent.left.parent = parent;

        child.right = parent;
        child.parent = grandparent;
        parent.parent = child;

        if (grandparent != blackSentinelNode)
        {
            if (grandparent.right == parent)  grandparent.right = child;
            else grandparent.left = child;
        }
        else root = child;
    }
}
            </pre>
        </div>

        <div class="search_Java">
            <pre>
//Returns pointer at node with the given key if succeed or NULL if failed
public Node&lt;T> Find(T data)
{
    Node&lt;T> node = root;

    while ((node != blackSentinelNode) && (node.data != data))
    {
        if (data > node.data) node = node.right;
        else node = node.left;
    }
    if (node == blackSentinelNode) return null;

    return node;
}
            </pre>
        </div>


        <!-- Python -->

        <div class="treeClass_PY">
            <pre>
class RedBlackTree:
    def __init__(self):
        self.nodeCounter = 0

        self.blackSentinelNode.left = blackSentinelNode
		self.blackSentinelNode.right = blackSentinelNode
		self.blackSentinelNode.parent = blackSentinelNode
		self.blackSentinelNode.isBlack = True

        root = blackSentinelNode

    def __rotateLeft(child,parent):
        ...
    def __rotateRight(child,parent):
        ...
    def Add(data):
        ...
    def Find(data):
        ...
    def Delete(data):
        ...
    def getSuccessor(node):
        ...
            </pre>
        </div>

        <div class="nodeClass_PY">
            <pre>
class Node:
    def __init__(self,data):
        self.data = data
        self.isBlack = False
        self.parent = None
        self.left = None
        self.right = None
            </pre>
        </div>

        <div class="insert_PY">
            <pre>
def Add(data):
    newNode = self.addBST(data)
    uncle = None

    while newNode != self.root and newNode.parent.isBlack == False:
        if newNode.parent == newNode.parent.parent.left:
            uncle = newNode.parent.parent.right

            #uncle is red
            if uncle.isBlack == False:
                newNode.parent.isBlack = True
                uncle.isBlack = True
                newNode.parent.parent.isBlack = False
                newNode = newNode.parent.parent
                continue

            #triangle case
            if newNode == newNode.parent.right:
                newNode = newNode.parent
                self.rotateLeft(newNode.right, newNode)

            #linear case
            newNode.parent.isBlack = True
            newNode.parent.parent.isBlack = False
            self.rotateRight(newNode.parent, newNode.parent.parent)
            break
        else:
            uncle = newNode.parent.parent.left

            if uncle.isBlack == False:
                newNode.parent.isBlack = True
                uncle.isBlack = True
                newNode.parent.parent.isBlack = False
                newNode = newNode.parent.parent
                continue

            if newNode == newNode.parent.left:
                newNode = newNode.parent
                self.rotateRight(newNode.left, newNode)

            newNode.parent.isBlack = True
            newNode.parent.parent.isBlack = False
            self.rotateLeft(newNode.parent, newNode.parent.parent)
            break

    root.isBlack = True
            </pre>
        </div>

        <div class="delete_PY">
            <pre>
def Delete(data):
   X = self.Find(data)
   W = None
   Y = None
   Z = None

  if X.left == self.blackSentinelNode or X.right == self.blackSentinelNode:
       Y = X
  else:
       Y = self.getSuccessor( X )

  if Y.left != self.blackSentinelNode:
       Z = Y.left
  else:
       Z = Y.right

  Z.parent = Y.parent

  if Y.parent == self.blackSentinelNode:
      root = Z
  elif Y == Y.parent.left:
      Y.parent.left  = Z
  else:
       Y.parent.right = Z

  if Y != X: 
      X.data = Y.data

  if Y.isBlack:
    while Z != root and Z.isBlack:
      if Z == Z.parent.left:
        W = Z.parent.right

        if not W.isBlack:
          W.isBlack = True
          Z.parent.isBlack = False
          self.rotateLeft(Z.parent, Z.parent.parent)
          W = Z.parent.right

        if W.left.isBlack and W.right.isBlack:
          W.isBlack = False
          Z = Z.parent
          continue

        if W.right.isBlack:
          W.left.isBlack = True
          W.isBlack = False
          self.rotateRight(W, W.parent)
          W = Z.parent.right

        W.isBlack = Z.parent.isBlack
        Z.parent.isBlack = W.right.isBlack = True
        self.rotateLeft(Z.parent, Z.parent.parent)
        Z = self.root
      else:
        W = Z.parent.left

        if not W.isBlack:
          W.isBlack = True
          Z.parent.isBlack = False
          self.rotateRight(Z.parent, Z.parent.parent)
          W = Z.parent.left

        if W.left.isBlack and W.right.isBlack:
          W.isBlack = False
          Z = Z.parent
          continue

        if W.left.isBlack:
          W.right.isBlack = True
          W.isBlack = False
          self.rotateLeft(W, W.parent)
          W = Z.parent.left

        W.isBlack = Z.parent.isBlack
        Z.parent.isBlack = True
        W.left.isBlack = True
        self.rotateRight(Z.parent, Z.parent.parent)
        Z = self.root

  Z.isBlack = True

  Y = None
            </pre>
        </div>

        <div class="rotation_PY">
            <pre>
#Rotates child onto parent; child is right parent's child
def rotateLeft(child, parent):
  grandparent = None

  if child != self.blackSentinelNode:
    grandparent = parent.parent
    parent.right = child.left
    if parent.right != self.blackSentinelNode:
      parent.right.parent = parent

    child.left = parent
    child.parent = grandparent
    parent.parent = child

    if grandparent != self.blackSentinelNode:
      if grandparent.right == parent:
        grandparent.right = child
      else:
        grandparent.left = child
    else:
      self.root = child

#Rotates child onto parent; child is left parent's child
def rotateRight(child, parent):
  grandparent = None

  if child != self.blackSentinelNode:
    grandparent = parent.parent
    parent.left = child.right
    if parent.left != self.blackSentinelNode:
      parent.left.parent = parent

    child.right = parent
    child.parent = grandparent
    parent.parent = child

    if grandparent != self.blackSentinelNode:
      if grandparent.right == parent:
        grandparent.right = child
      else:
        grandparent.left = child
    else:
      self.root = child
            </pre>
        </div>

        <div class="search_PY">
            <pre>
#Returns pointer at node with the given key if succeed or None if failed
def Find(data):
    node = self.root

    while node != self.blackSentinelNode and  node.data != data:
        if data > node.data:
             node = node.right
        else:
            node = node.left
    if node == self.blackSentinelNode:
        return None

    return node
            </pre>
        </div>
    </body>
</html>